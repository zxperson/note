一、字符编码问题

    1B(字节)=8(bit)比特位
    1KB = 1024B
    1MB = 1024KB
    1GB = 1024MB
    1TB = 1024GB    10100101  ‘中‘     utf-8 编码  
                    01010101110  ’中‘    utf-9 编码

    1. ASCII码，Unicode和UTF-8

        在计算机中，所有的数据在实际存储的时候都是用二进制来表示的(二进制1、0),那么问题来了，
    用哪些二进制数字表示哪些字符呢？如果每个人都约定一套自己的对应规则(编码)，那么在相互通信的时候(解码)，
    的时候就会很麻烦，因为每种编码方式，都会对应一种解码方式。

    于是美国国家标准局(ANSI)制定了ASCII码(American Standard Code for Information Interchange,美国标准信息交换码).
        
        1位二进制有两种状态：1、0 。2位二进制数可以有4中组合，可以表示4个字符，那么 7位 二进制数字有 128种组合，可以表示128个字符,
    称之为：标准的ASCII码。如果用8位表示，可以表示256个字符，减去之前的128个，后面128个称之为 扩展ASCII码。


        对于英文来说，ASCII码足够用了，但是对于汉语，或者其他字符比较多的语言来说，ASCII码显然不满足要求，
    因此，出现了unicode编码。Unicode编码和UCS编码是相同的，如果用2个字节表示字符，这种称之为UCS-2或者UTF-16，
    如果用4个字节表示字符，这种我们称之为UCS-4，或者UTF-32。但是无论是UTF-16还是UTF-32，都和C语言不兼容，
    于是UTF-8诞生了。千万注意：UTF-16和UTF-32，仅仅是unicode编码的一种具体的实现形式，unicode编码是一个编码集合。
    unicode编码现在已经包含了100多万个字符。unicode编码可以和其他的编码进行转换。

        UTF-8编码是可变长短的，英文字母用一个字节表示，中文通常是3个字节。UTF-8兼容ASCII码。

    在Python3中我们用的是什么编码呢？
        In [1]: import sys
        In [2]: sys.getdefaultencoding()
        Out[2]: 'utf-8'
    在Python3中默认编码就是UTF-8，python2中默认是ASCII码，所有python2中要想支持中文，文件头部需要加上#coding:utf-8
    在Python2里 不要 使用 sys.setdefaultencoding()来改变默认的编码。用了以后可能会产生意想不到的bug。

    中文unicode编码对照表 http://www.chi2ko.com/tool/CJK.htm   

    那么问题来了，unicode编码是如何变成utf-8编码的？首先UTF-8具有下面的特征：

        1.编码为U+0000~U+007F的字符只占一个字节，就是0x00~0x7F，和ASCII码兼容。

        2.编码大于U+007F的字符用2~6个字节表示，每个字节的最高位都是1，而ASCII码的最高位都是0，
            因此非ASCII码字符的表示中不会出现ASCII码字节（也就不会出现0字节）。

        3.用于表示非ASCII码字符的多字节序列中，第一个字节的取值范围是0xC0~0xFD，
            根据它可以判断后面有多少个字节也属于当前字符的编码。后面每个字节的取值范围都是0x80~0xBF，见下面的详细说明。

        4.UCS定义的所有231个字符都可以用UTF-8编码表示出来。

        5.UTF-8编码最长6个字节，BMP字符的UTF-8编码最长三个字节。

        6. 0xFE和0xFF这两个字节在UTF-8编码中不会出现。

    具体来说，UTF-8编码有以下几种格式：
        U-00000000 – U-0000007F:    0xxxxxxx
        U-00000080 – U-000007FF:    110xxxxx 10xxxxxx
        U-00000800 – U-0000FFFF:    1110xxxx 10xxxxxx 10xxxxxx
        U-00010000 – U-001FFFFF:    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
        U-00200000 – U-03FFFFFF:    111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
        U-04000000 – U-7FFFFFFF:    1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

    第一个字节要么最高位是0（ASCII字节），要么最高两位都是1，最高位之后1的个数决定后面有多少个字节也属于当前字符编码，
    例如111110xx，最高位之后还有四个1，表示后面有四个字节也属于当前字符的编码。后面每个字节的最高两位都是10，可以和第一个字节区分开。
    这样的设计有利于误码同步，例如在网络传输过程中丢失了几个字节，很容易判断当前字符是不完整的，也很容易找到下一个字符从哪里开始，
    结果顶多丢掉一两个字符，而不会导致后面的编码解释全部混乱了。上面的格式中标为x的位就是UCS编码，
    最后一种6字节的格式中x位有31个，可以表示31位的UCS编码，UTF-8就像一列火车，第一个字节是车头，
    后面每个字节是车厢，其中承载的货物是UCS编码。UTF-8规定承载的UCS编码以大端表示，也就是说第一个字节中的x是UCS编码的高位，
    后面字节中的x是UCS编码的低位。

    例如U+00A9（©字符）的二进制是10101001，编码成UTF-8是11000010 10101001（0xC2 0xA9），
    但不能编码成11100000 10000010 10101001，UTF-8规定每个字符只能用尽可能少的字节来编码。

    例如'中'这个字符的unicode编码为4e2d，属于这个范围：U-00000800 – U-0000FFFF 。二进制为：100 111000 101101(15位)，
    转换为UFT-8的二进制为：11100100 10111000 10101101，转换为十六进制为e4b8ad
                           1110xxxx 10xxxxxx 10xxxxxx (16个x)
                           11100100 10111000 10101101

    在计算机的硬件中保存的全部是二进制，想一个问题，例如我们在向硬件写入数据之前，是不是要先把数据按照一定的编码转换为二进制，才能存进去
    当数据保存在硬盘里，我们想打开看看里面的内容的时候，编码是如何进行转换的呢？
    首先，一个文件保存在硬盘里，在保存到硬盘之前，先要进行编码成二进制，然后才能保存，我们假设硬盘上的数据用的是UTF-8编码。
    接着，系统会把UTF-8编码的二进制转换为unicode编码的二进制，然后加载到内存里，此时，内存里的二进制，是通过unicode编码而来的。
    保存在硬盘里的二进制，是通过UTF-8编码而来的。

    回过头来，在Python3中，字符串有两种类型，一种为str类型，一种是bytes类型。
        1). str类型：
        In [1]: hex(ord('中'))
        Out[1]: '0x4e2d'       注意：这是unicode编码

        In [2]: type('中')
        Out[2]: str

        2). bytes类型

        In [1]: a = '中'.encode('utf-8')

        In [2]: a
        Out[2]: b'\xe4\xb8\xad'    注意；这里是UTF-8编码

        In [3]: type(a)
        Out[3]: bytes

    在python3中，我们如何查看字符的unicode编码的十六进制表示呢？
        In [12]: '中'.encode('unicode-escape')
        Out[12]: b'\\u4e2d'

        In [13]: '中国'.encode('unicode-escape')
        Out[13]: b'\\u4e2d\\u56fd'



        # unicode编码表:http://www.chi2ko.com/tool/CJK.htm


    










